{"type":"summary","summary":"Nail Plank Challenge: Debugging Codility Solution","leafUuid":"335a4d43-98cc-4d23-bdef-5369237812f3"}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/mnt/d/src/LifeHackingScripts","sessionId":"936b9463-2a16-4100-a854-2f281b4b1148","version":"2.0.1","gitBranch":"main","type":"user","message":{"role":"user","content":[{"type":"text","text":"<ide_selection>The user selected the lines 1 to 39 from Untitled-1:\n| [1] | [2] | [1] | 1 | 1 |\n| [3, 5, 1, 1, 1] | [4, 6, 7, 1, 2] | [1] | -1 | -1 |\n| [1, 1] | [5, 3] | [2, 4] | 1 | 1 |\n| [2, 5] | [4, 7] | [2, 6] | 2 | 2 |\n| [1, 1, 1] | [5, 4, 3] | [2] | 1 | 1 |\n| [1, 5] | [3, 7] | [4, 6] | -1 | -1 |\n| [5, 7] | [6, 9] | [3, 8] | -1 | -1 |\n| [1, 4, 6] | [3, 5, 8] | [2, 2, 2, 7] | -1 | -1 |\n| [1, 2] | [5, 3] | [4] | -1 | -1 |\n| [1, 1, 2] | [6, 4, 5] | [5] | -1 | -1 |\n| [1, 3, 5] | [4, 6, 8] | [2, 4, 7] | 3 | 3 |\n| [1, 2, 3] | [5, 5, 4] | [5] | -1 | -1 |\n| [2, 6] | [5, 9] | [1, 7] | -1 | -1 |\n| [1, 4] | [3, 6] | [2, 2, 2, 5] | 4 | 4 |\n| [2, 2, 5] | [4, 3, 7] | [3, 6] | 2 | 2 |\n| [3, 5] | [6, 8] | [3, 7] | 2 | 2 |\n| [2, 2, 2] | [6, 5, 4] | [3] | 1 | 1 |\n| [2, 2, 5] | [6, 4, 8] | [3] | -1 | -1 |\n| [3, 3, 3] | [7, 5, 9] | [6] | -1 | -1 |\n| [1, 3] | [5, 6] | [4] | 1 | 1 |\n| [2, 4, 6] | [3, 5, 7] | [5] | -1 | -1 |\n| [1, 2, 3, 4] | [4, 5, 6, 7] | [3, 6] | 2 | 2 |\n| [1, 5] | [2, 6] | [3, 7] | -1 | -1 |\n| [3] | [7] | [1, 2, 5, 8] | 3 | 3 |\n| [1, 5, 8] | [4, 7, 10] | [3, 3, 6, 9] | 4 | 4 |\n| [1,1,2,3,9,3,4,11] | [1,1,2,3,9,3,4,11] | [11,7,3,4,1,1,1,1,2,1,2,9] | 12 | 12 |\n| [1, 1, 2] | [10, 5, 3] | [4] | -1 | -1 |\n| [1, 3, 5] | [4, 6, 8] | [2, 7] | -1 | -1 |\n| [1, 2, 3, 4, 5] | [5, 5, 5, 5, 5] | [5] | 1 | 1 |\n| [1, 1, 1] | [10, 5, 7] | [6] | -1 | -1 |\n| [1, 3] | [4, 6] | [2, 5] | 2 | 2 |\n| [5, 5, 5, 5] | [5, 5, 5, 5] | [5, 5, 5, 5] | 1 | 1 |\n| [1, 4, 4, 7] | [3, 6, 8, 9] | [5, 2, 8] | 3 | 3 |\n| [2, 2, 2] | [4, 5, 6] | [3, 5] | 1 | 1 |\n| [1, 5, 5] | [3, 7, 9] | [2, 6, 8] | 2 | 2 |\n| [3, 3, 6] | [5, 7, 8] | [4, 6, 7] | 2 | 2 |\n| [1, 2, 5, 6] | [4, 4, 7, 8] | [3, 6] | 2 | 2 |\n| [1, 3, 3, 7] | [2, 5, 8, 9] | [2, 4, 8] | 3 | 3 |\n\n\nThis may or may not be related to the current task.</ide_selection>"},{"type":"text","text":"You are a Software Engineer with expertise in debugging code, creating test cases, and solving coding challenges. Your goal is to help users improve their coding solutions by providing test cases which the solution fail.\n\nYou will be given a coding challenge and a solution with test results. Based on what is provided, you need to determine the appropriate type of help to give.\n\n<challenge>\nYou are given two non-empty arrays A and B consisting of N integers. These arrays represent N planks. More precisely, A[K] is the start and B[K] the end of the K−th plank.\n\nNext, you are given a non-empty array C consisting of M integers. This array represents M nails. More precisely, C[I] is the position where you can hammer in the I−th nail.\n\nWe say that a plank (A[K], B[K]) is nailed if there exists a nail C[I] such that A[K] ≤ C[I] ≤ B[K].\n\nThe goal is to find the minimum number of nails that must be used until all the planks are nailed. In other words, you should find a value J such that all planks will be nailed after using only the first J nails. More precisely, for every plank (A[K], B[K]) such that 0 ≤ K < N, there should exist a nail C[I] such that I < J and A[K] ≤ C[I] ≤ B[K].\n\nFor example, given arrays A, B such that:\n\n    A[0] = 1    B[0] = 4\n    A[1] = 4    B[1] = 5\n    A[2] = 5    B[2] = 9\n    A[3] = 8    B[3] = 10\nfour planks are represented: [1, 4], [4, 5], [5, 9] and [8, 10].\n\nGiven array C such that:\n\n    C[0] = 4\n    C[1] = 6\n    C[2] = 7\n    C[3] = 10\n    C[4] = 2\nif we use the following nails:\n\n0, then planks [1, 4] and [4, 5] will both be nailed.\n0, 1, then planks [1, 4], [4, 5] and [5, 9] will be nailed.\n0, 1, 2, then planks [1, 4], [4, 5] and [5, 9] will be nailed.\n0, 1, 2, 3, then all the planks will be nailed.\nThus, four is the minimum number of nails that, used sequentially, allow all the planks to be nailed.\n\nWrite a function:\n\ndef solution(A, B, C)\n\nthat, given two non-empty arrays A and B consisting of N integers and a non-empty array C consisting of M integers, returns the minimum number of nails that, used sequentially, allow all the planks to be nailed.\n\nIf it is not possible to nail all the planks, the function should return −1.\n\nFor example, given arrays A, B, C such that:\n\n    A[0] = 1    B[0] = 4\n    A[1] = 4    B[1] = 5\n    A[2] = 5    B[2] = 9\n    A[3] = 8    B[3] = 10\n\n    C[0] = 4\n    C[1] = 6\n    C[2] = 7\n    C[3] = 10\n    C[4] = 2\nthe function should return 4, as explained above.\n\nWrite an efficient algorithm for the following assumptions:\n\nN and M are integers within the range [1..30,000];\neach element of arrays A, B and C is an integer within the range [1..2*M];\nA[K] ≤ B[K].\n</challenge>\n\n<user_solution>\n\n```\nimport bisect\n\n# printDebug = True\n# runCustomTests = True\n\ndef solution(A, B, C):\n    '''\n    N = len(A) = len(B), planks\n    M = len(C), nails\n\n    I need search in O(log(n)): sortedArray, removal in O(1): LinkedList, dict, set\n\n    '''\n    sortedPlanks = sorted(sorted(zip(A, B), key = lambda x: -x[1]), key = lambda x: x[0])\n    # if printDebug:\n        # print(\"sortedPlanks: \", sortedPlanks)\n    minimalPlanks = []\n    for i in range(len(A)):\n        a, b = sortedPlanks[i]\n        # # print(a, b)\n        # Eliminate planks that fully contain other planks, e.g., if (1,2) and (0,5) are present, we can eliminate (0,5)\n        if i < len(A) - 1:\n            nextB = sortedPlanks[i + 1][1]\n            # # print(\"nextB\", nextB)\n            if nextB <= b:\n                # # print(\"nextB <= b\")\n                continue\n        minimalPlanks.append((a,b,True))\n    # if printDebug:\n        # print(\"minimalPlanks: \", minimalPlanks)\n    # The boolean is to mark it was not nailed yet\n    removed = 0\n    nailCount = 0\n    posHit = set()\n    while removed < len(minimalPlanks) and nailCount < len(C):\n        nail = C[nailCount]\n        pos = max(0, bisect.bisect_left(minimalPlanks, nail, key = lambda x: x[0]) - 1)\n        # if printDebug:\n            # print(\"pos, nail\", pos, nail)\n        if nail not in posHit:\n            posHit.add(nail)\n            while pos > 0 and minimalPlanks[pos-1][0] <= nail and minimalPlanks[pos-1][1] >= nail:\n                pos -= 1\n                # if printDebug:\n                    # print(\"pos adjusted -\", pos)\n            while pos < len(minimalPlanks) - 1 and minimalPlanks[pos][1] < nail and minimalPlanks[pos+1][0] <= nail and minimalPlanks[pos+1][1] >= nail:\n                pos += 1\n                # if printDebug:\n                    # print(\"pos adjusted +\", pos)\n            while pos < len(minimalPlanks) and minimalPlanks[pos][0] <= nail and minimalPlanks[pos][1] >= nail:\n                if minimalPlanks[pos][2]:\n                    minimalPlanks[pos] = (minimalPlanks[pos][0], minimalPlanks[pos][1], False)\n                    removed += 1\n                pos += 1\n            # if printDebug:\n                # print(\"nailIndex:\", nailCount, \"\\nPlanks hit from minimal:\", removed)\n        nailCount += 1\n    # if printDebug:\n        # print(\"Finally\\nnailIndex:\", nailCount, \"\\nPlanks hit from minimal:\", removed)\n        # print(\"Final minimalPlanks:\", minimalPlanks)\n    return nailCount if removed == len(minimalPlanks) else -1\n```\n\n</user_solution>\n\n<test_results>\n# Codility Tests:\n\n## Example tests\n\n▶example\nexample test✔OK\n\n## Correctness tests\n\n▶extreme_single\nsingle nail and single plank✔OK\n▶extreme_point\nnail is a point [1, 1]✔OK\n▶few_nails_in_the_same_place\nfew nails are in the same place✔OK\n▶random_small\nrandom sequence, length = ~100✔OK\n\n## Performance tests\n\n▶random_medium\nrandom sequence, length = ~10,000✘WRONG ANSWER\ngot -1 expected 7827\n▶random_large\nrandom sequence, length = ~30,000✔OK\n▶extreme_large_planks\nall large planks, length = ~30,000✔OK\n▶large_point\nall planks are points, length = ~30,000\n\n# Custom tests:\n\n| A | B | C | Expected Result | Actual Result |\n| [1] | [2] | [1] | 1 | 1 |\n| [3, 5, 1, 1, 1] | [4, 6, 7, 1, 2] | [1] | -1 | -1 |\n| [1, 1] | [5, 3] | [2, 4] | 1 | 1 |\n| [2, 5] | [4, 7] | [2, 6] | 2 | 2 |\n| [1, 1, 1] | [5, 4, 3] | [2] | 1 | 1 |\n| [1, 5] | [3, 7] | [4, 6] | -1 | -1 |\n| [5, 7] | [6, 9] | [3, 8] | -1 | -1 |\n| [1, 4, 6] | [3, 5, 8] | [2, 2, 2, 7] | -1 | -1 |\n| [1, 2] | [5, 3] | [4] | -1 | -1 |\n| [1, 1, 2] | [6, 4, 5] | [5] | -1 | -1 |\n| [1, 3, 5] | [4, 6, 8] | [2, 4, 7] | 3 | 3 |\n| [1, 2, 3] | [5, 5, 4] | [5] | -1 | -1 |\n| [2, 6] | [5, 9] | [1, 7] | -1 | -1 |\n| [1, 4] | [3, 6] | [2, 2, 2, 5] | 4 | 4 |\n| [2, 2, 5] | [4, 3, 7] | [3, 6] | 2 | 2 |\n| [3, 5] | [6, 8] | [3, 7] | 2 | 2 |\n| [2, 2, 2] | [6, 5, 4] | [3] | 1 | 1 |\n| [2, 2, 5] | [6, 4, 8] | [3] | -1 | -1 |\n| [3, 3, 3] | [7, 5, 9] | [6] | -1 | -1 |\n| [1, 3] | [5, 6] | [4] | 1 | 1 |\n| [2, 4, 6] | [3, 5, 7] | [5] | -1 | -1 |\n| [1, 2, 3, 4] | [4, 5, 6, 7] | [3, 6] | 2 | 2 |\n| [1, 5] | [2, 6] | [3, 7] | -1 | -1 |\n| [3] | [7] | [1, 2, 5, 8] | 3 | 3 |\n| [1, 5, 8] | [4, 7, 10] | [3, 3, 6, 9] | 4 | 4 |\n| [1,1,2,3,9,3,4,11] | [1,1,2,3,9,3,4,11] | [11,7,3,4,1,1,1,1,2,1,2,9] | 12 | 12 |\n| [1, 1, 2] | [10, 5, 3] | [4] | -1 | -1 |\n| [1, 3, 5] | [4, 6, 8] | [2, 7] | -1 | -1 |\n| [1, 2, 3, 4, 5] | [5, 5, 5, 5, 5] | [5] | 1 | 1 |\n| [1, 1, 1] | [10, 5, 7] | [6] | -1 | -1 |\n| [1, 3] | [4, 6] | [2, 5] | 2 | 2 |\n| [5, 5, 5, 5] | [5, 5, 5, 5] | [5, 5, 5, 5] | 1 | 1 |\n| [1, 4, 4, 7] | [3, 6, 8, 9] | [5, 2, 8] | 3 | 3 |\n| [2, 2, 2] | [4, 5, 6] | [3, 5] | 1 | 1 |\n| [1, 5, 5] | [3, 7, 9] | [2, 6, 8] | 2 | 2 |\n| [3, 3, 6] | [5, 7, 8] | [4, 6, 7] | 2 | 2 |\n| [1, 2, 5, 6] | [4, 4, 7, 8] | [3, 6] | 2 | 2 |\n| [1, 3, 3, 7] | [2, 5, 8, 9] | [2, 4, 8] | 3 | 3 |\n\n</test_results>\n\nBefore providing your response, use the scratchpad below to analyze the situation:\n\n<scratchpad>\nThen plan your response accordingly.\n</scratchpad>\n\nBased on the information provided, you need to handle the case:\n\n**Solution provided with runtime errors or wrong answers**\n- Create a specific test case that would cause the current solution to fail\n- Explain what type of input would expose the bug (edge case, boundary condition, etc.)\n- If it's a runtime error, focus on what might cause the crash\n- If it's a wrong answer, show an example where the logic fails\n- Provide the expected vs actual output for your test case\n- Give hints about what part of the logic needs to be reconsidered\n\nYour response should be educational and encourage the user to think through the problem themselves. Focus on teaching programming concepts and debugging techniques rather than providing direct solutions.\n\nYour final response should include your analysis and guidance, but should not include the scratchpad content."}]},"uuid":"e36189c0-1e3d-4bc4-9bee-156d3c13466b","timestamp":"2025-10-05T08:29:03.279Z"}
{"parentUuid":"e36189c0-1e3d-4bc4-9bee-156d3c13466b","isSidechain":false,"userType":"external","cwd":"/mnt/d/src/LifeHackingScripts","sessionId":"936b9463-2a16-4100-a854-2f281b4b1148","version":"2.0.1","gitBranch":"main","message":{"id":"msg_01Ac5W3CgspTaR8iXCHG138f","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"text","text":"Looking at your solution, I can see it's failing on the `random_medium` performance test. The issue lies in your optimization strategy - specifically, how you're trying to eliminate \"redundant\" planks.\n\n## The Problem with Your Approach\n\nYour code attempts to eliminate planks that are fully contained within other planks:\n\n```python\nif nextB <= b:\n    continue\n```\n\nHowever, this logic is **flawed** because it doesn't account for the sequential nature of the nail array. A plank that seems \"redundant\" might actually require a nail that comes earlier in the sequence than the nail that covers the \"larger\" plank.\n\n## Test Case That Exposes the Bug\n\nHere's a simple test case your solution would fail:\n\n**Input:**\n- A = [1, 2]\n- B = [5, 3]\n- C = [2, 4]\n\n**Expected Output:** 2 (need both nails: nail at position 2 for plank [1,5], nail at position 4 for plank [2,3])\n\n**What Your Code Does:**\n1. After sorting: `[(1, 5), (2, 3)]`\n2. Your elimination logic sees that plank `(2, 3)` has `nextB` (which would be checking if there's overlap), but the condition might not trigger correctly\n3. Even if both planks are kept, the issue is that nail at position 2 hits both planks, so your code might return 1 instead of 2\n\nActually, let me provide a clearer failing case:\n\n**Input:**\n- A = [1, 3]\n- B = [2, 5]  \n- C = [1, 4]\n\n**Expected:** 2\n- Plank [1, 2] needs nail at position 1 (index 0)\n- Plank [3, 5] needs nail at position 4 (index 1)\n\n**Your Code Might Return:** 1 or -1, because your elimination logic might incorrectly remove one of the planks.\n\n## Key Issues to Reconsider\n\n1. **Plank Elimination**: You cannot eliminate planks based solely on geometric containment. The ORDER of nails in array C matters critically.\n\n2. **Binary Search Position**: Your `bisect_left` usage with the `key` parameter and subsequent position adjustments seem overly complex and error-prone.\n\n3. **Marking Strategy**: Using a tuple with a boolean flag and creating new tuples to mark planks as nailed is inefficient and error-prone.\n\n## Hints for Debugging\n\n1. The problem requires finding the **minimum prefix** of the C array that nails all planks\n2. Consider using **binary search on the answer** (the number of nails needed)\n3. For each candidate answer, verify if using the first K nails can cover all planks\n4. Think about how to efficiently check if a set of nails covers all planks\n\nTry testing your code with smaller, hand-crafted examples where you can trace through the logic step by step. Pay special attention to cases where planks overlap or are contained within each other, and where the required nails are not in ascending position order."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":34050,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":34050,"ephemeral_1h_input_tokens":0},"output_tokens":730,"service_tier":"standard"}},"requestId":"req_011CTojh5tbTDp2Eh4VG6TVt","type":"assistant","uuid":"9c9b5573-a849-4c36-a10f-c42bce0d3ccf","timestamp":"2025-10-05T08:29:24.150Z"}
{"parentUuid":"9c9b5573-a849-4c36-a10f-c42bce0d3ccf","isSidechain":false,"userType":"external","cwd":"/mnt/d/src/LifeHackingScripts","sessionId":"936b9463-2a16-4100-a854-2f281b4b1148","version":"2.0.1","gitBranch":"main","type":"user","message":{"role":"user","content":[{"type":"text","text":"It is expected to return 1, and it does return 1. So the issue is different. Ultrathink++ on where the bug is."}]},"uuid":"7010a67c-efd2-443f-a061-4595ae1f786d","timestamp":"2025-10-05T08:37:12.806Z"}
{"parentUuid":"7010a67c-efd2-443f-a061-4595ae1f786d","isSidechain":false,"userType":"external","cwd":"/mnt/d/src/LifeHackingScripts","sessionId":"936b9463-2a16-4100-a854-2f281b4b1148","version":"2.0.1","gitBranch":"main","message":{"id":"msg_011zyq5xH3t1PdEcyLvGprZj","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"thinking","thinking":"Let me carefully analyze the user's solution again. They're saying my test case is wrong - they expect it to return 1 and it does return 1.\n\nLet me reconsider the test case I gave:\n- A = [1, 3]\n- B = [2, 5]  \n- C = [1, 4]\n\nPlanks: [1, 2] and [3, 5]\nNails: position 1 (index 0) and position 4 (index 1)\n\nActually, wait:\n- Nail at position 1 hits plank [1, 2]? Yes (1 <= 1 <= 2)\n- Nail at position 1 hits plank [3, 5]? No (1 < 3)\n- Nail at position 4 hits plank [1, 2]? No (4 > 2)\n- Nail at position 4 hits plank [3, 5]? Yes (3 <= 4 <= 5)\n\nSo we need both nails, answer should be 2.\n\nBut the user is saying expected is 1 and actual is 1. That's strange. Let me re-read...\n\nOh wait, I think the user is saying that for MY test case, it's expected to return 1 (not 2 as I claimed), and it does return 1. So my test case analysis was wrong.\n\nLet me trace through more carefully what the issue might be.\n\nThe failing test is:\n- random_medium: got -1 expected 7827\n\nSo the solution is returning -1 when it should find an answer. This means the solution is incorrectly determining that not all planks can be nailed, when in fact they can be.\n\nLet me look at the algorithm more carefully:\n\n1. It sorts planks by start position (primary) and end position descending (secondary)\n2. It tries to eliminate \"redundant\" planks - planks that are fully contained in others\n\n\n3. It processes nails sequentially, marking planks as nailed\n\nI'll investigate the elimination logic carefully. The code checks if the next plank's end is less than or equal to the current plank's end, which could incorrectly skip important planks. This might cause the algorithm to prematurely conclude that not all planks can be nailed.\n\nThe sorting and elimination process seems to be creating a critical flaw in the nail placement strategy. I need to understand how this impacts the overall plank coverage calculation. The sorting strategy reveals a critical flaw in the previous elimination approach. By first sorting descending on end positions and then ascending on start positions, we create a sequence that prevents correctly identifying contained planks.\n\nThe current sorting method prioritizes longer planks while maintaining their relative start positions. This means (1, 10) remains first, followed by (1, 5), then (2, 3). When processing these planks, the algorithm incorrectly skips potentially overlapping or contained segments.\n\nThe key issue lies in how the comparison and continuation logic fails to properly assess plank relationships, potentially missing important containment or overlap scenarios that could impact the minimal plank selection. I see the sorting reveals an interesting elimination strategy. The algorithm first sorts planks by end position descending, then by start position ascending. This creates a sequence where potentially overlapping planks are grouped together. \n\nThe elimination process checks consecutive planks, potentially removing those that are fully contained within others. However, the current logic seems counterintuitive - it's keeping smaller planks when larger planks might more efficiently cover the same area.\n\nThe key insight is about plank containment and efficient coverage. By keeping smaller planks when larger ones exist, we might be introducing unnecessary complexity or suboptimal nail placement. If a plank is fully contained within another, nailing the inner plank effectively covers the outer plank. When planks share the same start point, this becomes clear - a nail in the shorter plank ensures the longer plank is also nailed. \n\nI'm seeing a pattern where containment depends on the next plank's start and end relative to the current plank. If the next plank's start is greater than or equal to the current plank's start, and its end is less than or equal to the current plank's end, it's completely contained. This means we can skip the outer plank since nailing the inner plank accomplishes the same goal.\n\nThe sorting strategy - arranging planks by start ascending and breaking ties with end descending - helps identify these nested plank relationships efficiently. By comparing adjacent planks' boundaries, we can determine which planks can be eliminated from our nailing strategy. I'm tracking the plank containment logic and nail placement strategy. The key observation is how planks overlap and which ones get eliminated during sorting. When processing nails, we're using binary search to efficiently locate potential plank matches. The current approach checks if a nail hits multiple planks, potentially marking them as covered. The implementation seems to handle edge cases by carefully positioning the search starting point, ensuring we don't miss potential plank intersections. This section advances the position and processes planks that can be hit by the current nail. It iterates through planks at the nail's position, marking them as hit and tracking the number of removed planks. The code ensures each plank is processed only once by checking if it hasn't already been marked, and incrementally moves through planks that can be reached by the current nail. An optimization prevents redundant processing of nails at the same position.\n\nThe analysis reveals a potential issue with plank modification and binary search behavior. The current implementation creates new tuples without fundamentally altering the list's sorting structure. The function's return condition depends on whether all planks have been successfully nailed, which might indicate incomplete plank processing or an unresolved search strategy.\n\nTwo critical scenarios emerge that could compromise the nail placement algorithm: incorrect plank elimination or flawed nail processing. The core problem lies in how planks containing other planks are handled, potentially losing critical tracking information during nail placement.\n\nA specific scenario illustrates this complexity: when a larger plank contains a smaller plank, the current logic might incorrectly skip or fail to track nail coverage, leading to potential missed opportunities for efficient plank nailing.\n\nThe example with planks (1, 10) and (5, 6), and a nail at position 2, reveals a fundamental flaw where the algorithm fails to recognize that the nail actually hits the larger encompassing plank, not just the smaller contained plank.\n\nThis reveals a systemic issue in the elimination and nail processing logic that could significantly impact the algorithm's accuracy in determining minimal nail placements.\n\nThe current approach incorrectly skips or removes planks based on incomplete criteria, potentially leading to incorrect nail count calculations. The sorting and comparison mechanism needs a more nuanced strategy to correctly handle overlapping plank ranges and nail interactions.\n\nThe key insight is understanding how nails interact with different sized planks, especially when one plank completely contains another, which requires a more sophisticated elimination and validation process. If a smaller plank is contained within a larger one, we can't simply discard the larger plank. A nail hitting the smaller plank doesn't guarantee coverage for the entire larger plank.\n\nThe core challenge is tracking nail placement to ensure complete coverage of all planks, even those that seem redundant. We must carefully consider how each nail impacts different plank sizes and positions.\n\nThe key insight is that containment doesn't automatically solve our nail placement problem. We need a more nuanced approach to minimize nails while guaranteeing all planks are secured. The nail at position 2 fails to nail the entire set of planks. Specifically, while it covers (1, 10), it misses (5, 6) completely. This reveals a critical gap in the nail placement strategy. The current approach cannot guarantee complete plank coverage, necessitating a different solution or additional nail placement considerations.\n\nThe optimization logic for nail processing contains a subtle flaw. Even if a nail position has been previously examined, its effectiveness might change depending on the current state of plank nailing. This means simply skipping previously seen nail positions could lead to incomplete coverage.\n\nLet's analyze the nail placement scenario carefully. The algorithm systematically processes nails, attempting to mark unprocessed planks with each nail. However, duplicate nail positions might still offer unique opportunities for plank coverage, depending on the current state of the nailing process.\n\nIn the example with planks (1, 5) and (6, 10), and nails [3, 3, 8], we see an interesting pattern. The first nail at position 3 marks one plank, the duplicate nail at the same position is skipped, and the final nail at position 8 marks the second plank. This suggests the algorithm's approach of tracking processed positions while still allowing comprehensive plank coverage.\n\nThe binary search logic seems to be a critical component, potentially involving finding the appropriate starting point for nail placement relative to the minimal planks. I'm noticing some complexity in how the search determines the initial position for nail processing.\n\nThe adjustment loop appears designed to navigate through overlapping planks, ensuring we identify the leftmost plank that can be hit by a specific nail. This involves carefully checking start and end positions to determine the most appropriate plank for nail placement.\n\nThe first loop shifts the position leftward when a previous plank can cover the nail, while the second loop moves forward when current planks cannot be hit and a subsequent plank can accommodate the nail.\n\nThese intricate movements help pinpoint the precise plank position that matches the nail's location, accounting for potential complex plank arrangements.\n\nThe code systematically tracks and updates plank status, marking planks that can be removed and incrementing the position to ensure comprehensive coverage across the plank sequence.\n\nThe nested loop structure suggests a nuanced approach to handling multiple potential plank configurations, carefully navigating through potential gaps and overlapping ranges.\n\nBy tracking the nail's position and comparing it against plank boundaries, the algorithm methodically identifies which planks can be potentially removed while maintaining a precise tracking mechanism.\n\nThe example demonstrates the algorithm's ability to handle complex scenarios with multiple plank ranges, showing how it methodically checks and marks planks based on the nail's precise location.\n\nI'm investigating potential edge cases where the binary search might not function as expected, particularly focusing on how the search handles nail positioning relative to plank start and end positions. The key concern is ensuring the search correctly identifies plank insertions and potential scenarios where nails cannot cover specific planks.\n\nMy current analysis suggests the binary search approach using `bisect.bisect_left()` with a key parameter should theoretically work, but I want to thoroughly examine potential boundary conditions that might cause unexpected behavior.\n\nSpecifically, I'm exploring scenarios like planks starting after all available nails, which could potentially trigger a -1 return value, indicating an uncoverable plank. The goal is to confirm the algorithm's robustness in handling these marginal cases.\n\nThe implementation uses a clever max-based indexing strategy to ensure array access remains within bounds, though I'm carefully tracing potential scenarios where index manipulation might introduce unexpected complications.\n\nThe edge case involving completely eliminated planks reveals a subtle logical challenge. If all original planks get removed during processing, the current logic might incorrectly suggest zero nails are needed, potentially masking scenarios requiring multiple nail placements.\n\nThe example with planks spanning (1, 10), (2, 9), and (3, 8) highlights a critical validation scenario where simply returning zero could misrepresent the actual nail requirements. This suggests the need for a more robust verification mechanism that confirms not just plank elimination, but also validates the completeness of the nail coverage.\n\nThe specific test case demanding 7827 nails implies complex overlapping plank configurations where unique nail placements become crucial. This hints at potential algorithmic limitations in tracking nail distribution across intricate plank arrangements.\n\nThe core issue seems rooted in how the elimination and nail counting process handles edge scenarios with extensively nested or overlapping planks, potentially leading to premature termination or incorrect nail count calculations.\n\nExamining the scenario with identical plank positions reveals a subtle processing flaw where duplicate planks might cause unexpected skipping during iteration, potentially disrupting the nail placement strategy.\n\nThe sorting mechanism prioritizes end positions in descending order, then start positions in ascending order, creating a complex elimination sequence that could inadvertently exclude some planks.\n\nWhile initially concerning, the core insight emerges that identical planks can be effectively covered by a single nail, aligning with the problem's fundamental requirement of nailing all planks.\n\nThe elimination logic systematically compares adjacent planks, using their end positions to determine which can be skipped. For the current example with planks (1, 10), (1, 5), and (2, 3), the process involves carefully tracking potential overlaps and minimal coverage.\n\nAt the first iteration, the algorithm checks whether the next plank's end position falls within the current plank's range, potentially allowing for strategic nail placement that minimizes total nails used.\n\nThe critical insight emerges when examining nail positions: a single nail at position 2 or 5 could potentially cover multiple planks. However, the current implementation risks incorrectly eliminating valid plank coverage scenarios, potentially leading to an incorrect minimum nail count.\n\nThis suggests the need for a more sophisticated approach that comprehensively tracks plank intersections and nail placement possibilities, ensuring no valid solution is prematurely discarded. The elimination strategy for planks has a subtle flaw in its containment logic. When sorting planks by start and end positions, the current approach incorrectly skips planks based on incomplete comparisons.\n\nThe key issue emerges with planks of different start positions. Simply comparing end points isn't sufficient to determine containment. A plank like (2, 3) isn't automatically excluded by a broader plank like (1, 10) just because its end is within the broader range.\n\nThe correct containment check requires verifying both start and end conditions. If a subsequent plank's start is greater than or equal to the current plank's start, and its end is less than or equal to the current plank's end, then it's truly contained.\n\nThis means the elimination process should prioritize more restrictive planks - those with smaller, more precise ranges - while ensuring accurate nested interval detection.\n\nThe example walkthrough reveals the complexity: some planks can be hit by nails, while others cannot, making a simple elimination strategy challenging to implement correctly.\n\nThe sorting rule prioritizes planks with smaller starts and larger ends, creating a nuanced ordering that helps identify containment relationships between planks.\n\nWhen planks have overlapping ranges, the algorithm must carefully track which planks can be nailed and which cannot, considering scenarios where multiple planks are nested within a larger plank.\n\nThe key insight emerges from a three-plank scenario where containment relationships become intricate: some planks might be contained within a larger plank, yet not directly related to each other.\n\nThis suggests the elimination process needs a more sophisticated approach to handle complex plank arrangements, especially when determining nail placement across multiple, potentially nested planks.\n\nThe example reveals a critical flaw: by breaking down a single containable plank into multiple smaller planks, we might inadvertently create separate nail requirements that cannot be satisfied simultaneously.\n\nAnalyzing the proposed nail positions of 3 and 7, I discover an interesting solution. Nail 3 successfully covers two planks: (1, 10) and (2, 5), while nail 7 covers (1, 10) and (6, 9). This strategic placement ensures complete coverage of all planks with just two nails.\n\nThe key insight is finding nail positions that maximize overlap across multiple planks, ultimately reducing the total number of nails needed. In this case, two nails are sufficient to nail all planks.\n\nI'm now contemplating edge cases that might challenge this approach, particularly scenarios involving complex plank arrangements or potential algorithmic blind spots.\n\nThe current adjustment logic seems limited, only incrementing one position at a time. This could potentially miss critical plank configurations where multiple planks exist between the initial position and a nail's valid location.\n\nConsider a specific scenario: planks spanning different ranges, where the initial positioning might not immediately reveal a valid nail placement. The incremental movement could inadvertently skip over crucial planks that could actually be nailed.\n\nThe example demonstrates this potential weakness: with planks [(1, 2), (4, 5), (7, 8), (10, 11)] and a nail at 10, the current method might not correctly navigate to the appropriate plank.\n\nThe key challenge involves ensuring comprehensive traversal across potential plank ranges, accounting for gaps and ensuring precise nail placement identification.\n\nI'll analyze the forward adjustment mechanism carefully. The loop advances position by checking multiple critical conditions simultaneously: current plank's end, next plank's start and end relative to the nail's location.\n\nThe iteration continues when:\n- Current position is within array bounds\n- Current plank's end is less than nail\n- Next plank's start is less than or equal to nail\n- Next plank's end is greater than or equal to nail\n\nThis systematic progression allows handling scenarios with multiple potential plank ranges, ensuring accurate nail positioning across complex configurations.\n\nThe algorithm methodically explores adjacent planks, incrementing position until the precise matching range is identified or boundary conditions are met. I'm exploring potential edge cases in the plank positioning algorithm. The backward adjustment loop seems designed to find the leftmost valid plank for a nail, moving back while previous planks can contain the nail. Initially, this approach looks correct - we want to start from the leftmost possible plank.\n\nThe binary search positioning using bisect_left with a key function aims to identify the initial insertion point. There might be subtle nuances in how this positioning works, especially when dealing with nail locations relative to plank ranges.\n\nI'm curious about potential scenarios where the initial positioning could lead to unexpected behavior, particularly around boundary conditions or edge cases involving nail placement. I'm examining the sorting strategy for planks, focusing on how the two-stage sorting process impacts plank selection. The first sort by negative end position ensures descending order of plank lengths, while the stable sort by start position creates a nuanced ordering. When planks share the same start point, the longer plank (with larger end) takes precedence. \n\nThe elimination logic hinges on comparing end positions, specifically skipping planks whose end points are shorter or equal to the current plank's end. This suggests a strategic filtering mechanism that prioritizes longer, more comprehensive plank coverage.\n\nThe sorting approach seems designed to optimize plank selection by preferentially choosing longer planks that start earlier, creating an efficient elimination strategy for overlapping intervals.\n\nThe current investigation is exploring potential sources of unexpected behavior, with careful examination of tuple modifications and potential edge cases in the sorting and filtering process.\n\nI'm scrutinizing how planks are marked and counted, particularly focusing on the `removed` counter increment mechanism. The core concern centers on ensuring each plank is processed exactly once, without unintended multiple modifications.\n\nThe current hypothesis suggests the counting logic appears sound - incrementing `removed` only when a plank hasn't been previously nailed. However, subtle interactions between tuple reassignment and state tracking might introduce unexpected complications.\n\nI'm sensing a need to fundamentally reframe the problem-solving approach, recognizing that the current debugging strategy hasn't yet revealed the underlying issue.\n\nThe algorithm's termination conditions warrant careful examination. We stop when either all planks are nailed or all available nails are exhausted. This suggests a potential edge case where nail allocation might prematurely halt before a complete solution is found.\n\nThe critical question emerges: Could the current implementation be overly conservative, potentially rejecting valid solutions that require utilizing all available nails?\n\nThe nail processing logic increments the nail counter unconditionally, even if a specific nail position hasn't been previously encountered. This means we're tracking processed nails, not necessarily nails that successfully nail planks.\n\nThe return mechanism elegantly captures this nuance - returning the number of nails processed only if all planks are successfully nailed, otherwise signaling failure with -1.\n\nThe optimization with `posHit` adds an interesting layer of complexity, ensuring each nail position is processed uniquely while maintaining the overall algorithmic integrity. We process nail positions systematically, incrementing our nail count even for duplicates. This ensures we track all potential nails, regardless of whether they actually nail any planks. The key is understanding that each nail position is considered, but only unique positions actively mark planks. Duplicate positions simply advance our tracking without additional processing.\n\nThe scenario of identical planks reveals an interesting edge case: when all planks are the same, a single nail effectively covers the entire set. This demonstrates the elimination logic's precision in handling uniform plank configurations.\n\nI'm curious about nested or fully contained plank scenarios, particularly with chained intervals like (1, 10) and (2, 9), which might introduce complex nail placement challenges.\n\nThe elimination process systematically checks each plank's containment, ultimately selecting the most strategically positioned plank for nailing. However, without access to the specific random test case, pinpointing the exact bug remains elusive.\n\nThe test suite's successful custom cases suggest the issue is nuanced and potentially hidden within the random medium test parameters.\n\nDiving deeper into the algorithm's core mechanics, I'm focusing on potential nail processing failures. The binary search implementation might harbor a subtle logic error preventing complete plank coverage. My investigation centers on how planks are marked during nail placement, suspecting a critical tracking mechanism could be malfunctioning.\n\nThe key diagnostic steps involve meticulously tracing the nail processing logic, particularly examining how binary search determines plank markability and ensuring no valid nailing scenarios are inadvertently missed.\n\nI'm scrutinizing the backward adjustment loop, which shifts position based on nail placement. The current implementation might not correctly handle edge cases where nail positioning intersects multiple plank ranges.\n\nThe bisect_left initialization and subsequent positional modifications suggest a potential indexing or boundary condition that could prevent accurate plank marking.\n\nLet me trace the specific scenario with nail 5 and planks [(1,3), (4,6), (7,9)] to understand the precise mechanics of position determination and nail coverage.\n\nThe bisect_left operation identifies the insertion point, initially positioning at plank (4,6). After backward adjustment, the position remains stable since the previous plank doesn't fully contain the nail.\n\nWhen examining nail 3 with planks [(1,2), (3,4), (5,6)], the initial bisect_left returns index 1, starting at plank (1,2). Backward movement isn't possible, so I'll check plank coverage.\n\nThe first plank (1,2) doesn't cover nail 3, triggering a forward adjustment. By checking adjacent plank boundaries, I can shift to the next plank (3,4), which appears to potentially contain the nail. The forward movement looks promising for nail coverage verification.\n\nI'm exploring edge cases systematically, particularly scenarios where the nail might fall outside expected plank ranges. The current investigation focuses on understanding how bisect_left handles nail positions relative to plank boundaries, especially when the nail exceeds or falls between planks.\n\nThe approach involves methodically testing different nail and plank configurations to identify potential algorithmic inconsistencies or boundary condition failures.","signature":"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"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":34986,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":34986,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CTokKHNuNFxux1bFHa3vb","type":"assistant","uuid":"24eb47bf-8463-4abf-8da8-eadf29b8c1b4","timestamp":"2025-10-05T08:41:08.733Z"}
{"parentUuid":"24eb47bf-8463-4abf-8da8-eadf29b8c1b4","isSidechain":false,"userType":"external","cwd":"/mnt/d/src/LifeHackingScripts","sessionId":"936b9463-2a16-4100-a854-2f281b4b1148","version":"2.0.1","gitBranch":"main","message":{"id":"msg_011zyq5xH3t1PdEcyLvGprZj","type":"message","role":"assistant","model":"claude-sonnet-4-5-20250929","content":[{"type":"text","text":"Looking at this more carefully, I need to trace through the elimination logic with a specific problematic pattern.\n\nLet me create a test case that should expose the bug:\n\n**Test Case:**\n```python\nA = [1, 2, 3]\nB = [5, 4, 6]  \nC = [2, 5]\n```\n\nLet me trace through your algorithm:\n\n**Step 1: Sorting**\n```python\nsorted(sorted(zip(A, B), key = lambda x: -x[1]), key = lambda x: x[0])\n```\n\nInitial pairs: `(1,5), (2,4), (3,6)`\n\nAfter first sort by `-x[1]` (end descending): `(3,6), (1,5), (2,4)`\n\nAfter second sort by `x[0]` (start ascending, stable): `(1,5), (2,4), (3,6)`\n\n**Step 2: Elimination**\n```python\nfor i in range(len(A)):\n    a, b = sortedPlanks[i]\n    if i < len(A) - 1:\n        nextB = sortedPlanks[i + 1][1]\n        if nextB <= b:\n            continue\n```\n\n- i=0: `(1,5)`, nextB=4. Is `4 <= 5`? **YES** → Skip `(1,5)`\n- i=1: `(2,4)`, nextB=6. Is `6 <= 4`? NO → Keep `(2,4)`  \n- i=2: `(3,6)` → Keep `(3,6)`\n\n**Result: `minimalPlanks = [(2,4), (3,6)]`**\n\n**The Problem:**\n\nYou eliminated plank `(1,5)` because you thought `(2,4)` being contained in it means any nail hitting `(2,4)` also hits `(1,5)`. \n\n**But `(2,4)` is NOT contained in `(1,5)`!**\n\nThe plank `(2,4)` starts at position 2 and ends at position 4.\nThe plank `(1,5)` starts at position 1 and ends at position 5.\n\nWhile it's true that `(2,4)` is geometrically within `(1,5)`, your elimination logic is checking `nextB <= b`, which checks if the NEXT plank's end is <= CURRENT plank's end. Since `4 <= 5`, you skip the current plank `(1,5)`.\n\n**Your assumption:** \"If next plank is contained in current plank, skip current\" is correct IN THEORY.\n\n**Your implementation:** You're assuming that after sorting by start position, `nextB <= currentB` means next is contained in current. This is TRUE.\n\n**BUT HERE'S THE BUG:** With nails `[2, 5]`:\n\n- Nail at position 2 hits: `(1,5)` ✓, `(2,4)` ✓  \n- Nail at position 5 hits: `(1,5)` ✓, `(3,6)` ✓\n\nIf you only track `[(2,4), (3,6)]`:\n- You need nail at position 2 for `(2,4)` \n- You need nail at position 5 for `(3,6)`\n- Answer: 2 ✓\n\nThis seems fine! So my test case doesn't break it...\n\nLet me think harder about when this WOULD break...\n\n**AH! I found it:**\n\n```python\nA = [1, 4]\nB = [3, 6]\nC = [2, 5, 5, 5, 7]\n```\n\nPlanks: `(1,3)`, `(4,6)`  \nSorted: `(1,3)`, `(4,6)`\n\nElimination: Both kept (nextB=6 > b=3)\n\nNow with `posHit` optimization:\n- Nail 0 (pos 2): hits `(1,3)`, added to `posHit`\n- Nail 1 (pos 5): hits `(4,6)`, added to `posHit`  \n- **All planks nailed, return 2** ✓\n\nStill correct...\n\n**Actually, I think the bug is here:**\n\nWhat if there are planks where the EARLIER one in the sorted order should be kept but is eliminated?\n\nTry: \n```python\nA = [1, 3, 3]\nB = [10, 5, 8]\nC = [4, 6]\n```\n\nAfter sorting by start then end(desc): `(1,10), (3,8), (3,5)`\n\nElimination:\n- i=0: `(1,10)`, nextB=8. `8 <= 10`? YES → Skip!\n- i=1: `(3,8)`, nextB=5. `5 <= 8`? YES → Skip!\n- i=2: `(3,5)` → Keep\n\n`minimalPlanks = [(3,5)]`\n\nBut the original planks were `(1,10), (3,5), (3,8)`.\n\n- Can nail at position 4 hit `(1,10)`? YES\n- Can nail at position 4 hit `(3,5)`? YES  \n- Can nail at position 4 hit `(3,8)`? YES\n\nAll three can be hit by nail at position 4! Answer should be 1.\n\nYour algorithm: Only tracking `(3,5)`, nail at position 4 hits it. Answer: 1 ✓\n\n**Okay I need to think about when it returns -1 incorrectly...**\n\nThe algorithm returns -1 when `removed < len(minimalPlanks)` after processing all nails. This means it couldn't nail all the \"minimal\" planks.\n\nWhat if a minimal plank CAN'T be nailed, but it was derived from eliminating larger planks that COULD be nailed?\n\n**WAIT - HERE'S THE ACTUAL BUG:**\n\nYour **backward adjustment loop** can get stuck!\n\n```python\nwhile pos > 0 and minimalPlanks[pos-1][0] <= nail and minimalPlanks[pos-1][1] >= nail:\n    pos -= 1\n```\n\nThis moves backward to find the LEFTMOST plank hit by the nail. But if planks have the SAME start position, and you're checking planks with identical starts, you might not correctly identify which one to start from!\n\nAfter elimination, you keep planks with the SMALLEST end for each start position. But when searching, if multiple planks COULD have had the same start (before elimination), your binary search might land in the wrong spot!\n\n**The root cause:** Your elimination removes planks in a way that breaks the binary search assumptions!"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":34986,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":34986,"ephemeral_1h_input_tokens":0},"output_tokens":15104,"service_tier":"standard"}},"requestId":"req_011CTokKHNuNFxux1bFHa3vb","type":"assistant","uuid":"b6d8df4b-d435-4e98-a438-992c8989f892","timestamp":"2025-10-05T08:41:37.114Z"}
